前阵子，有小伙伴在我B站的算法教程底下留言
![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200413111142544-219640324.png)
小伙伴们有任何疑问或者希望我讲解任何内容，都可以在我的[个人B站](https://space.bilibili.com/325538782)或公众号（xmg_mj）留言哦，我会尽我最大能力、尽量抽时间去写文章或录视频来回应大家。

## 关于快速幂
其实快速幂相关的问题，是参加算法竞赛（NOI、ACM等）的小伙伴必须要掌握的一小块基础内容。当然，就算你不打算参加算法竞赛，个人觉得只要你是一名程序员，就必须要掌握快速幂算法。

在《计算机程序设计艺术》一书中就有提到快速幂算法，此书的英文名是The Art of Computer Programming，简称TAOCP。
![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414154917929-480748682.jpg)

TAOCP出自**Donald Ervin Knuth**前辈之手。Knuth前辈是在计算机领域成就颇丰的知名科学家，是著名的KMP算法的发明人之一，在1974年获得“计算机领域的诺贝尔奖”：图灵奖（当年他才36岁）。目前TAOCP已经出版了第1、2、3、4A卷，按照计划，还有第4B、5、6、7卷未出版。第一卷首发于1968年，Knuth前辈今年是82岁高寿，据说他计划在105岁之前完成这部巨著。

![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414145658604-204170215.jpg)

关于TAOCP，微软创始人Bill Gates曾说过
> If you think you're a really good programmer… read (Knuth's) Art of Computer Programming… You should definitely send me a resume if you can read the whole thing.

大概意思是：如果你认为自己是一位非常优秀的程序员，那就应该阅读Knuth的TAOCP；如果你能读懂全部内容，可以直接给我发送一份简历。据说Knuth前辈的言辞更加犀利：看不懂就别当程序员了！不过TAOCP对于新手来说，阅读难度的确比较大，书中的所有示例都使用了Knuth前辈自创的**MIX汇编语言**。

## 阅读本文之前的提醒
今天就抽空写一篇文章来讲解一下经典的快速幂算法哈。不过要想彻底看懂本文，有几个前提条件
- 熟悉算法中的2个基础概念：时间复杂度、空间复杂度
    - 如果你压根没听过这2个概念，说明你的算法基础**完全**为0，真的没有在开玩笑！
    - 可以向公众号发送**复杂度**获取相关教程
- 熟悉二进制和十进制的转换
    - 如果连这个都不熟悉的话，那你的编程底子就真的需要好好补补啦
    - 可以向公众号发送**进制**获取相关教程
- 熟悉常见的位运算操作
    - n & 1的结果是n最低二进制位的值，也可以用于判断n的奇偶性
    - 求正整数n / 2，可以用位运算取代：n >> 1
    - 如果不明白上述操作的原理，可以向公众号发送**位运算**获取相关教程

## 什么是幂（Power）？
众所周知，x的n次幂，是指x的n次方，也就是n个x相乘，比如2的4次幂就是2 \* 2 \* 2 \* 2。

为了简化描述，后面x的n次幂，我就简化为x ^ n（本文中的 ^ 并不是按位异或的意思）

那如何通过编程求幂？假设**只考虑x、n是整数且n大于等于0**的情况，最容易想到的方法如下所示（这里采用的编程语言是Java，但没有涉及Java特殊的语法。所以就算你没用过Java，也可以看懂）
```java
int power(int x, int n) {
    int result = 1;
    while (n-- > 0) {
        result *= x;
    }
    return result;
}
```
很显然，这种方法的时间复杂度是**O(n)**、空间复杂度是**O(1)**

## 什么是快速幂？
所谓快速幂，就是用效率更高（时间复杂度更低）的方法求幂，可以将时间复杂度优化至**O(logn)**。这里介绍2种求解方法：递归、非递归
### 递归

![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414150118769-1111696142.png)

根据上图中的等式，不难写出以下代码
```java
int fastPower(int x, int n) {
    if (n == 0) return 1;
    int result = fastPower(x, n >> 1);
    result *= result;
    return (n & 1) == 0 ? result : result * x;
}
```
这个方法的时间、空间复杂度都是**O(logn)**。

那如何分析出这个方法的复杂度呢？

如果你的算法功底比较薄弱，可以代入特定值作一个大概的分析，比如当n为16时，方法的递归调用过程如下图所示
![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414150139170-1060016099.png)


不难看出，每次调用时，n的规模都减半，所以时间和空间复杂度都是**O(logn)**

如果你的算法功底还行，那就可以用更专业的方法去分析它的复杂度（没有一定的算法基础，可能会看不懂）
- 这其实是典型的应用分治策略的算法
- 假设T(n)是数据规模为n时的时间复杂度，不难得出递推式：**T(n) = T(n / 2) + O(1)**
- 最后通过**主定理**（Master Theorem）可以直接得出结论：**T(n) = O(logn)**

### 非递归
我们以求3 ^ 21为例子，来分析一下非递归的代码应该怎么写。

首先21的二进制形式是10101
![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414163529491-2133162931.png)

![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200414150101963-959599942.png)

不难得出以下结论
- 3 ^ n（n为2、4、8、16）都可以由3 ^ 1累乘出来
- 每一个3 ^ n都有对应的二进制位
    - 3 ^ 1对应二进制位的值是1，其实是二进制**10101**的最后1位
    - 3 ^ 2对应二进制位的值是0，其实是二进制**1010**的最后1位
    - 3 ^ 4对应二进制位的值是1，其实是二进制**101**的最后1位
    - 3 ^ 8对应二进制位的值是0，其实是二进制**10**的最后1位
    - 3 ^ 16对应二进制位的值是1，其实是二进制**1**的最后1位
- 如果3 ^ n对应二进制位的值是**0**，就不用乘进最终结果
    - 比如3 ^ (8 * **0**)、3 ^ (2 * **0**)
    - 因为它们最终的值都是3 ^ 0，也就是1
- 如果3 ^ n对应二进制位的值是**1**，就需要乘进最终结果
    - 比如3 ^ (16 * **1**)、3 ^ (4 * **1**)、3 ^ (1 * **1**)

所以，综合以上种种结论，可以总结出以下解题步骤
- 利用3 ^ 1，不断累乘出3 ^ n（n为2、4、8、16）
- 每当累乘出一个3 ^ n，就查看其对应二进制位的值是1还是0，来决定是否要将它乘进最终结果
```java
int fastPower(int x, int n) {
    int result = 1;
    while (n != 0) {
        if ((n & 1) == 1) {
            result *= x;
        }
        x *= x;
        n >>= 1;
    }
    return result;
}
```
代入3和21，fastPower(3, 21)的执行流程如下
#### 第1轮while循环
- 第4行代码
    - n的二进制是10101（十进制是21）
    - x = 3 ^ 1, 其对应二进制位的值是1（n的最后一个二进制位）
    - 所以**需要**执行第5行代码：将x乘进最终结果
    - result = 3 ^ 1
- 第7行代码
    - x = (3 ^ 1) * (3 ^ 1) = 3 ^ 2
- 第8行代码
    - n右移1位，其二进制变成了1010（对应的十进制是啥？不重要！！！）

#### 第2轮while循环
- 第4行代码
    - n的二进制是1010
    - x = 3 ^ 2, 其对应二进制位的值是0（n的最后一个二进制位）
    - 所以**不需要**执行第5行代码：不需要将x乘进最终结果
    - result = 3 ^ 1
- 第7行代码
    - x = (3 ^ 2) * (3 ^ 2) = 3 ^ 4
- 第8行代码
    - n右移1位，其二进制变成了101（对应的十进制是啥？不重要！！！）

#### 第3轮while循环
- 第4行代码
    - n的二进制是101
    - x = 3 ^ 4, 其对应二进制位的值是1（n的最后一个二进制位）
    - 所以**需要**执行第5行代码：将x乘进最终结果
    - result = (3 ^ 1) * (3 ^ 4)
- 第7行代码
    - x = (3 ^ 4) * (3 ^ 4) = (3 ^ 8)
- 第8行代码
    - n右移1位，其二进制变成了10（对应的十进制是啥？不重要！！！）

#### 第4轮while循环
- 第4行代码
    - n的二进制是10
    - x = 3 ^ 8, 其对应二进制位的值是0（n的最后一个二进制位）
    - 所以**不需要**执行第5行代码：不需要将x乘进最终结果
    - result = (3 ^ 1) * (3 ^ 4)
- 第7行代码
    - x = (3 ^ 8) * (3 ^ 8) = 3 ^ 16
- 第8行代码
    - n右移1位，其二进制变成了1（对应的十进制是啥？不重要！！！）

#### 第5轮while循环
- 第4行代码
    - n的二进制是1
    - x = 3 ^ 16, 其对应二进制位的值是1（n的最后一个二进制位）
    - 所以**需要**执行第5行代码：将x乘进最终结果
    - result = (3 ^ 1) * (3 ^ 4) * (3 ^ 16)
- 第7行代码
    - x = (3 ^ 16) * (3 ^ 16) = 3 ^ 32
- 第8行代码
    - n右移1位，其二进制变成了0

#### 最后
- 由于n = 0，所以退出while循环
- 最终result = (3 ^ 1) * (3 ^ 4) * (3 ^ 16)
- 复杂度分析
    - 每执行一次while的循环体，n >>= 1, 会导致n的值减半
    - 所以时间复杂度：**O(logn)**、空间复杂度：**O(1)**

## Leetcode
Leetcode上的第50号题[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)，刚好就可以用今天讲解的快速幂算法。以下是我的代码实现
```java
// 递归
double myPow(double x, int n) {
    if (n == 0) return 1;
    if (n == -1) return 1 / x;
    double half = myPow(x, n >> 1);
    half *= half;
    return ((n & 1) == 1) ? half * x : half;
}

// 非递归
double myPow(double x, int n) {
    long y = (n < 0) ? -((long) n) : n;
    double result = 1.0;
    while (y > 0) {
        if ((y & 1) == 1) {
            result *= x;
        }
        x *= x;
        y >>= 1;
    }
    return (n < 0) ? (1 / result) : result;
}
```
需要提醒的是
- 这里我用的编程语言是Java，大家可以根据自己熟悉的编程语言，对一些语法细节作出相应的调整
- Leetcode上的n可能是个负数，所以上面的代码针对负数的情况作了一些处理

## 更多快速幂相关的问题
时间有限，这篇文章就先说到这了哈。给小伙伴们留2个快速幂相关的问题，有空的话，可以去研究一下
- 使用矩阵快速幂求斐波那契数列
- 请设计一个算法求x的y次幂模z的结果：(x ^ y) % z
    - 假设x、y都可能是很大的整数（y大于等于0，z不等于0）

如果你特别希望我写点什么方面的内容，也可以留言建议，谢谢。欢迎关注
![](https://img2020.cnblogs.com/blog/497279/202004/497279-20200410164835214-554855079.jpg)